<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Wheel of Fortune</title>
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <style>
    html, body { margin:0; padding:0; background:transparent; overflow:hidden; }
    .overlay { position: fixed; left:50%; top:50%; transform: translate(-50%, -40%) scale(0.94);
      opacity: 0; transition: opacity .95s ease, transform .95s ease; pointer-events:none; width:700px; height:700px;
      display:flex; align-items:center; justify-content:center; z-index:10; }
    .overlay.show { opacity:1; transform: translate(-50%, -50%) scale(1); pointer-events:auto; }
    canvas { width:1000px; height:1000px; display:block; }

    .editor { position:fixed; right:16px; top:16px; width:400px; max-height:92vh; overflow:auto; background:rgba(20,20,20,.95); color:#fff;
      font-family:system-ui,sans-serif; border-radius:12px; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.08);
      z-index:9999; display:none; }
    .editor.show { display:block; }
    .editor h2{ margin:0 0 10px 0; font-size:18px; }
    .row{ display:flex; gap:8px; margin-bottom:8px; }
    .row input[type="text"]{ flex:1; padding:8px 10px; border-radius:8px; border:1px solid #333; background:#141414; color:#fff; }
    .row input[type="number"]{ width:84px; padding:8px 10px; border-radius:8px; border:1px solid #333; background:#141414; color:#fff; }
    .row button, .editor .btn { padding:8px 10px; border-radius:8px; border:1px solid #333; background:#1f1f1f; color:#fff; cursor:pointer; }
    .list{ display:grid; gap:6px; margin:10px 0; }
    .item{ display:grid; grid-template-columns:1fr 80px auto auto auto auto; gap:6px; align-items:center; background:#151515; border:1px solid #2a2a2a; border-radius:8px; padding:8px; }
    .item span{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .muted{ color:#9aa0a6; font-size:12px; }
    .pill{ display:inline-block; padding:4px 8px; border-radius:999px; background:#0f172a; border:1px solid #334155; color:#cbd5e1; font-size:12px; }

    .result-banner { position: absolute; left: 50%; top: 8%; transform: translate(-50%, -20%) scale(0.95); opacity: 0; padding: 14px 22px;
      border-radius: 14px; background: rgba(17, 17, 17, 0.80); color: #fff; font-family: system-ui, sans-serif; font-weight: 800; letter-spacing: .3px;
      line-height: 1; font-size: 48px; box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08); backdrop-filter: blur(6px);
      pointer-events: none; z-index: 20; transition: opacity .35s ease, transform .35s ease; }
    .result-banner.show { opacity: 1; transform: translate(-50%, 0) scale(1); }

    .admin { display:flex; gap:6px; align-items:center; margin:6px 0 10px; }
    .admin input { flex:1; padding:6px 8px; border-radius:8px; border:1px solid #333; background:#141414; color:#fff; }
  </style>
</head>
<body>
  <div id="resultBanner" class="result-banner" aria-hidden="true"></div>
  <div id="overlay" class="overlay">
    <canvas id="wheel" width="1000" height="1000"></canvas>
  </div>

  <div id="editor" class="editor" aria-hidden="true">
    <h2>üéõÔ∏è Wheel editor <span class="pill">open via ?edit=1</span></h2>
    <div class="muted">Server-backed config. Viewers do not see this panel.</div>

    <div class="admin">
      <input id="adminKey" type="text" placeholder="X-Admin-Key (only for editor owner)">
      <button id="saveKeyBtn" class="btn">Save Key</button>
      <button id="loadCfgBtn" class="btn">Load</button>
    </div>

    <div class="row" style="margin-top:6px;">
      <input id="newLabel" type="text" placeholder="New prize‚Ä¶">
      <input id="newWeight" type="number" min="0" step="0.1" value="10" title="Percent">
      <button id="addBtn">Add</button>
    </div>
    <div class="muted" id="sumInfo"></div>
    <div class="list" id="list"></div>
    <div class="bar">
      <button class="btn" id="normalizeBtn">Normalize to 100%</button>
      <button class="btn" id="saveBtn">Save (server)</button>
      <button class="btn" id="resetBtn">Reset</button>
      <button class="btn" id="hideBtn">Close</button>
      <button class="btn" id="exportBtn">Export</button>
      <button class="btn" id="importBtn">Import</button>
    </div>
    <textarea id="importArea" placeholder='Paste JSON here (from "Export") and click "Import".'></textarea>
  </div>

  <script>
    // ====== Server config helpers ======
    async function fetchServerConfig() {
      try {
        const r = await fetch("/config", { cache: "no-store" });
        if (!r.ok) return null;
        const j = await r.json();
        if (j?.ok && Array.isArray(j.items)) return j.items;
      } catch {}
      return null;
    }
    async function saveToServer(items) {
      const key = localStorage.getItem("ADMIN_KEY") || "";
      const r = await fetch("/config", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Admin-Key": key },
        body: JSON.stringify({ items })
      });
      return r.ok;
    }

    // ====== Data / persistence (local cache only) ======
    const STORAGE_KEY_V2 = "wheel.prizes.v2";
    const DEFAULT_ITEMS = [
      { label:"VIP na 24h", weight:10 }, { label:"≈öpiewasz 30s", weight:10 },
      { label:"Mem na IG", weight:10 },  { label:"Reroll", weight:10 },
      { label:"Wyb√≥r czatu", weight:10 },{ label:"Shot (18+)", weight:10 },
      { label:"Giveaway 1x", weight:10 },{ label:"Wyb√≥r mapy", weight:10 },
      { label:"Ban 5 min (joke)", weight:5 }, { label:"Reroll", weight:5 },
      { label:"Sub-Chat", weight:5 }, { label:"Losowy klip", weight:5 }
    ];

    function genId(){ return 'itm_' + Math.random().toString(36).slice(2,10) + Date.now().toString(36); }
    function sanitizeItem(it){
      const label = String(it?.label ?? "").trim();
      let weight = Number(it?.weight);
      if (!Number.isFinite(weight) || weight < 0) weight = 0;
      const id = String(it?.id || "");
      return { id: id || genId(), label, weight };
    }
    function loadItemsLocal(){
      try{
        const raw=localStorage.getItem(STORAGE_KEY_V2);
        if(raw){ const arr=JSON.parse(raw); if(Array.isArray(arr)&&arr.length) return arr.map(sanitizeItem); }
      }catch{}
      return DEFAULT_ITEMS.map(sanitizeItem);
    }
    function saveItemsLocal(items){ localStorage.setItem(STORAGE_KEY_V2, JSON.stringify(items.map(sanitizeItem))); }

    let ITEMS = []; let CONFIG_VERSION = 1;

    // ====== Drawing etc. ======
    const COLORS = ["#FF4D4F","#40A9FF","#73D13D","#FAAD14","#9254DE","#13C2C2","#EB2F96","#A0D911","#FFD666","#5CDBD3","#FF7A45","#597EF7"];
    const FULL_ROUNDS_MIN = 5, FULL_ROUNDS_MAX = 7;
    const BAG_SIZE = 50;
    const NO_REPEAT_BACK_TO_BACK = true;
    const AT_LEAST_ONE_THRESHOLD = 1;

    let spinBag = [], bagPos = 0, spinBagVersion = 0, lastPickedId = null, lastIndex = -1;
    const canvas = document.getElementById("wheel");
    const ctx = canvas.getContext("2d");
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio||1));
    (function setupCanvas(){ const cssW=1000, cssH=1000; canvas.width=cssW*dpr; canvas.height=cssH*dpr; canvas.style.width=cssW+"px"; canvas.style.height=cssH+"px"; ctx.setTransform(dpr,0,0,dpr,0,0); })();
    const W=1000,H=1000,CX=W/2,CY=H/2,R=Math.min(W,H)*0.45;
    let rotation = 0;
    let ACTIVE_SNAPSHOT = null;

    function modTau(x){ const TAU = 2*Math.PI; return ((x % TAU) + TAU) % TAU; }
    function getNormalizedWeightsFrom(items){
      const w = items.map(it=>Math.max(0, Number(it.weight)||0));
      const sum = w.reduce((a,b)=>a+b,0);
      if(sum<=0){ const eq=100/Math.max(1,items.length); return w.map(()=>eq); }
      return w.map(x=>x*(100/sum));
    }
    function buildSectors(items){
      const pct = getNormalizedWeightsFrom(items);
      const sectors = []; let acc=0;
      for(let i=0;i<items.length;i++){
        const startPct=acc, endPct=acc+pct[i]; acc=endPct;
        const start=(startPct/100)*2*Math.PI, end=(endPct/100)*2*Math.PI;
        sectors.push({ id:items[i].id, label:items[i].label, start, end, center:(start+end)/2 });
      }
      return sectors;
    }
    function shuffleInPlace(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
    function cloneItems(items){ return items.map(it=>({ id:it.id, label:it.label, weight:it.weight })); }

    function sectorUnderPointer(angle, sectors){
      const POINTER_ANGLE = -Math.PI/2;
      const rel = modTau(POINTER_ANGLE - modTau(angle));
      for (let i = 0; i < sectors.length; i++){
        const a = modTau(sectors[i].start), b = modTau(sectors[i].end);
        if (a <= b) { if (rel >= a && rel < b) return i; } else { if (rel >= a || rel < b) return i; }
      }
      return 0;
    }

    // helpers do tekstu po ≈Çuku
    function fitFontForArc(ctx, text, radius, arcAngle, maxPx = 42, minPx = 10) {
      const maxLen = radius * arcAngle * 0.9;
      let lo = minPx, hi = maxPx, best = minPx;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        ctx.font = `700 ${mid}px system-ui, sans-serif`;
        const w = ctx.measureText(text).width;
        if (w <= maxLen) { best = mid; lo = mid + 1; } else { hi = mid - 1; }
      }
      ctx.font = `700 ${best}px system-ui, sans-serif`;
      return best;
    }
    function ellipsize(ctx, text, maxWidth) {
      if (ctx.measureText(text).width <= maxWidth) return text;
      const ell = "‚Ä¶"; let s = text;
      while (s.length > 1 && ctx.measureText(s + ell).width > maxWidth) s = s.slice(0, -1);
      return s + ell;
    }

    function drawWheel(angle = 0) {
      const items = ACTIVE_SNAPSHOT || ITEMS;
      ctx.clearRect(0, 0, W, H);

      // t≈Ço pier≈õcienia
      ctx.beginPath();
      ctx.arc(CX, CY, R + 44, 0, 2 * Math.PI);
      ctx.fillStyle = "#deb887";
      ctx.fill();
      ctx.lineWidth = 10;
      ctx.strokeStyle = "#8b5a2b";
      ctx.stroke();

      // je≈ºeli brak pozycji ‚Äî narysuj tylko ≈õrodek i wska≈∫nik
      if (!items || items.length === 0) {
        // ≈õrodek
        const hubR0 = Math.max(22, R * 0.42);
        ctx.beginPath();
        ctx.arc(CX, CY, hubR0, 0, 2 * Math.PI);
        const hubGrad0 = ctx.createRadialGradient(CX, CY, 4, CX, CY, hubR0);
        hubGrad0.addColorStop(0, "#f1c27d");
        hubGrad0.addColorStop(1, "#8b5a2b");
        ctx.fillStyle = hubGrad0;
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#5e3d1e";
        ctx.stroke();

        // wska≈∫nik
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.moveTo(CX, CY - R - 16);
        ctx.lineTo(CX - 18, CY - R + 14);
        ctx.lineTo(CX + 18, CY - R + 14);
        ctx.closePath();
        ctx.fill();

        // obw√≥d
        ctx.beginPath();
        ctx.arc(CX, CY, R + 6, 0, 2 * Math.PI);
        ctx.strokeStyle = "rgba(255,255,255,.35)";
        ctx.lineWidth = 4;
        ctx.stroke();
        return;
      }

      const sectors = buildSectors(items);

      // sektory
      for (let i = 0; i < sectors.length; i++) {
        const s = sectors[i];
        const start = angle + s.start;
        theEnd   = angle + s.end;
        const end = theEnd; // (naprawa liter√≥wki na niekt√≥rych starych silnikach)
        const arcAngle = end - start;

        ctx.beginPath();
        ctx.moveTo(CX, CY);
        ctx.arc(CX, CY, R, start, end);
        ctx.closePath();

        const grad = ctx.createRadialGradient(CX, CY, R * 0.08, CX, CY, R);
        grad.addColorStop(0, COLORS[i % COLORS.length]);
        grad.addColorStop(1, COLORS[(i + 1) % COLORS.length]);
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,.6)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // napis
        const mid = start + arcAngle / 2;
        const rText = R * 0.72;
        const rawLabel = String(s.label || "");
        const fontPx = fitFontForArc(ctx, rawLabel, rText, arcAngle, 42, 10);
        ctx.font = `700 ${fontPx}px system-ui, sans-serif`;
        const maxLen = rText * arcAngle * 0.9;
        const label = ellipsize(ctx, rawLabel, maxLen);

        const tx = CX + Math.cos(mid) * rText;
        const ty = CY + Math.sin(mid) * rText;
        ctx.save();
        ctx.translate(tx, ty);
        ctx.rotate(mid + Math.PI / 2);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.lineWidth = Math.max(2, Math.round(fontPx * 0.12));
        ctx.strokeStyle = "rgba(0,0,0,0.55)";
        ctx.fillStyle = "#fff";
        ctx.shadowColor = "rgba(0,0,0,0.25)";
        ctx.shadowBlur = fontPx * 0.35;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.strokeText(label, 0, 0);
        ctx.fillText(label, 0, 0);
        ctx.restore();
      }

      // ≈õrodek
      const hubR = Math.max(22, R * 0.42);
      ctx.beginPath();
      ctx.arc(CX, CY, hubR, 0, 2 * Math.PI);
      const hubGrad = ctx.createRadialGradient(CX, CY, 4, CX, CY, hubR);
      hubGrad.addColorStop(0, "#f1c27d");
      hubGrad.addColorStop(1, "#8b5a2b");
      ctx.fillStyle = hubGrad;
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#5e3d1e";
      ctx.stroke();

      // wska≈∫nik
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.moveTo(CX, CY - R - 16);
      ctx.lineTo(CX - 18, CY - R + 14);
      ctx.lineTo(CX + 18, CY - R + 14);
      ctx.closePath();
      ctx.fill();

      // obw√≥d
      ctx.beginPath();
      ctx.arc(CX, CY, R + 6, 0, 2 * Math.PI);
      ctx.strokeStyle = "rgba(255,255,255,.35)";
      ctx.lineWidth = 4;
      ctx.stroke();

      // stojak
      ctx.fillStyle = "#8B5A2B";
      ctx.fillRect(CX - 55, CY + R + 12, 110, 115);
      ctx.fillStyle = "#6f451d";
      ctx.fillRect(CX - 130, CY + R + 120, 260, 28);
    }

    function getNormalizedWeights(){ return getNormalizedWeightsFrom(ITEMS); }

    function buildSpinBag(){
      const L = ITEMS.length;
      if (L === 0) {
        spinBag = [];
        bagPos = 0;
        spinBagVersion = CONFIG_VERSION;
        console.log("üß∞ Bag skipped (no items).");
        return;
      }

      const n = L;
      const norm = getNormalizedWeights();
      const desired = norm.map(p=>p*BAG_SIZE/100);

      let counts=new Array(n).fill(0), assigned=0, residuals=new Array(n).fill(0);
      for (let i=0;i<n;i++){ counts[i]=Math.floor(desired[i]); assigned+=counts[i]; residuals[i]=desired[i]-Math.floor(desired[i]); }
      for (let i=0;i<n;i++){ if (norm[i]>=AT_LEAST_ONE_THRESHOLD && counts[i]===0){ counts[i]++; assigned++; } }

      const byResidualDesc=[...Array(n).keys()].sort((a,b)=>residuals[b]-residuals[a]);
      const byResidualAsc=[...Array(n).keys()].sort((a,b)=>residuals[a]-residuals[b]);
      const byPctAsc=[...Array(n).keys()].sort((a,b)=>norm[a]-norm[b]);

      while(assigned<BAG_SIZE){ for(let k=0;k<n && assigned<BAG_SIZE;k++){ counts[byResidualDesc[k]]++; assigned++; } }
      if(assigned>BAG_SIZE){
        let iA=0,iB=0;
        while(assigned>BAG_SIZE && (iA<n || iB<n)){
          const i = (iA<n) ? byResidualAsc[iA++] : byPctAsc[iB++];
          if (counts[i]>0 && !(norm[i]>=AT_LEAST_ONE_THRESHOLD && counts[i]===1)){ counts[i]--; assigned--; }
        }
      }

      const bag=[];
      for (let i=0;i<n;i++){
        const id = ITEMS[i].id ?? (ITEMS[i].id = genId());
        for(let c=0;c<counts[i];c++) bag.push(id);
      }
      shuffleInPlace(bag);
      spinBag=bag; bagPos=0; spinBagVersion=CONFIG_VERSION;
      const dbg = counts.map((c,i)=>`${ITEMS[i]?.label||i}:${c}`).join(" | ");
      console.log(`üß∞ Bag built (${BAG_SIZE}):`, dbg);
    }

    function nextFromBag(){
      if(!spinBag || bagPos>=spinBag.length || spinBagVersion!==CONFIG_VERSION) buildSpinBag();
      if (spinBag.length === 0) { console.warn("Spin requested but no items."); return null; }
      let pickedId = spinBag[bagPos++];
      if (NO_REPEAT_BACK_TO_BACK && lastPickedId===pickedId && spinBag.length>1){
        if (bagPos<spinBag.length && spinBag[bagPos]!==lastPickedId){ const alt=spinBag[bagPos]; spinBag[bagPos]=pickedId; pickedId=alt; }
        else { for(let i=bagPos;i<spinBag.length;i++){ if (spinBag[i]!==lastPickedId){ const alt=spinBag[i]; spinBag[i]=pickedId; pickedId=alt; break; } } }
      }
      lastPickedId=pickedId;
      return pickedId;
    }

    function easeOutQuint(t){ return 1 - Math.pow(1 - t, 5); }

    async function spinToId(pickedId){
      if (!pickedId) return { index:-1, snap:null, label:"" };
      ACTIVE_SNAPSHOT = cloneItems(ITEMS);
      const SNAP = ACTIVE_SNAPSHOT; const sectors = buildSectors(SNAP);
      let pickedIdx = sectors.findIndex(s => s.id === pickedId);
      if (pickedIdx === -1) pickedIdx = 0;
      const picked = sectors[pickedIdx];

      const POINTER_ANGLE = -Math.PI/2; const TAU = 2*Math.PI;
      const startAngle = modTau(rotation); let baseTarget = POINTER_ANGLE - picked.center;

      while (baseTarget <= startAngle) baseTarget += TAU;
      const roundsInt = Math.floor(FULL_ROUNDS_MIN + Math.random()*(FULL_ROUNDS_MAX - FULL_ROUNDS_MIN + 1));
      const targetAngle = baseTarget + Math.max(FULL_ROUNDS_MIN, roundsInt) * TAU;

      const totalDuration = 5200; const t0 = performance.now();

      return new Promise(resolve=>{
        function frame(t){
          const p = Math.min(1, (t - t0) / totalDuration);
          const eased = easeOutQuint(p);
          rotation = startAngle + (targetAngle - startAngle) * eased;
          drawWheel(rotation);
          if (p < 1) requestAnimationFrame(frame);
          else {
            rotation = targetAngle;
            drawWheel(rotation);
            const winIdx = sectorUnderPointer(rotation, sectors);
            const winSec = sectors[winIdx];
            console.log(`üéØ WIN(byBag): ${picked.label} | WIN(byGeom): ${winSec.label} | same=${picked.id===winSec.id}`);
            lastIndex = pickedIdx;
            setTimeout(()=>{ ACTIVE_SNAPSHOT = null; }, 0);
            resolve({ index: pickedIdx, snap: SNAP, label: picked.label });
          }
        }
        requestAnimationFrame(frame);
      });
    }

    const overlay = document.getElementById("overlay");
    const queue = []; let spinning=false; let hideTimer=null;
    function showOverlay(){ clearTimeout(hideTimer); overlay.classList.add("show"); }
    function hideOverlay(afterMs = 1600) {
      clearTimeout(hideTimer);
      hideTimer = setTimeout(()=>{ overlay.classList.remove("show"); hideResult(); }, afterMs);
    }

    const resultBanner = document.getElementById("resultBanner");
    let resultTimer = null;
    function showResult(label, ms = 1800) {
      if (!resultBanner) return;
      clearTimeout(resultTimer);
      resultBanner.textContent = label || "";
      resultBanner.classList.add("show");
      resultBanner.setAttribute("aria-hidden", "false");
      resultTimer = setTimeout(hideResult, ms);
    }
    function hideResult() {
      if (!resultBanner) return;
      resultBanner.classList.remove("show");
      resultBanner.setAttribute("aria-hidden", "true");
    }

    function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }

    async function runQueue(){
      if (spinning) return;
      spinning=true;
      if (queue.length){ showOverlay(); await wait(400); }
      while (queue.length) {
        const pickedId = nextFromBag();
        const result = await spinToId(pickedId);
        if (result.label) {
          console.log(`‚úÖ [${bagPos}/${spinBag.length}] ${result.label}`);
          showResult(result.label, 1800);
          fetch('/chat/announce', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ label: result.label })
          }).catch(()=>{});
        }
        queue.shift();
        await wait(2000);
      }
      spinning=false;
      hideOverlay(1000);
    }

    // ====== WebSocket: auto-reconnect + watchdog + auto-reload ======
    const OBS_EDIT_MODE = new URLSearchParams(location.search).get("edit") === "1";
    const WS_URL = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws';

    let ws = null;
    let reconnectDelay = 1000;           // backoff start 1s
    let lastSignalAt = Date.now();       // ostatni sygna≈Ç od serwera
    const staleKickMs = 60_000;          // je≈õli 60s ciszy ‚Äî zerwij po≈ÇƒÖczenie (trafi w onclose => reconnect)
    const hardReloadEveryMs = 30 * 60_000; // twardy reload co 30 min (off w trybie edycji)

    function handleServerMessage(data) {
      if (data.type === "config" && Array.isArray(data.items)) {
        ITEMS = data.items.map(sanitizeItem);
        CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag();
        console.log("üîÑ Config updated from server");
        return;
      }
      if (data.action === "spin" && Number.isFinite(data.times)) {
        for (let i = 0; i < data.times; i++) queue.push(1);
        showOverlay(); runQueue(); return;
      }
    }

    async function fetchPending() {
  try {
    const r = await fetch('/spins/pending', { cache: 'no-store' });
    const j = await r.json();
    return Math.max(0, Number(j?.count || 0));
  } catch { return 0; }
}

async function consumePending(n) {
  try {
    const r = await fetch('/spins/consume', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ count: n })
    });
    const j = await r.json();
    return Math.max(0, Number(j?.taken || 0));
  } catch { return 0; }
}

async function catchUpPending() {
  const cnt = await fetchPending();
  if (cnt > 0) {
    const taken = await consumePending(cnt);
    if (taken > 0) {
      for (let i = 0; i < taken; i++) queue.push(1);
      showOverlay(); runQueue();
    }
  }
}

    function connectWS() {
      try { if (ws) ws.close(); } catch {}
      ws = new WebSocket(WS_URL);

      ws.onopen = async () => {
  console.log("‚úÖ WS connected", WS_URL);
  lastSignalAt = Date.now();
  reconnectDelay = 1000;
  await catchUpPending(); // <-- NOWE
};

ws.onmessage = async (evt) => {
  lastSignalAt = Date.now();
  try {
    const data = JSON.parse(evt.data);
    if (data.type === "config" && Array.isArray(data.items)) {
      ITEMS = data.items.map(sanitizeItem);
      CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag();
      return;
    }
    if (data.action === "pending" && Number.isFinite(data.count)) {
      await catchUpPending(); // <-- NOWE
      return;
    }
    if (data.action === "spin" && Number.isFinite(data.times)) {
      for (let i = 0; i < data.times; i++) queue.push(1);
      showOverlay(); runQueue();
      return;
    }
  } catch (e) {
    console.error("Bad WS message", e);
  }
};
      ws.onerror = (e) => {
        console.warn("WS error", e?.message || e);
        try { ws.close(); } catch {}
      };
      ws.onclose = () => {
        const wait = reconnectDelay;
        reconnectDelay = Math.min(reconnectDelay * 1.8, 15000);
        setTimeout(connectWS, wait);
      };

      // lokalny stra≈ºnik stagnacji
      const guard = setInterval(() => {
        if (!ws || ws.readyState !== WebSocket.OPEN) { clearInterval(guard); return; }
        if (Date.now() - lastSignalAt > staleKickMs) {
          console.warn("WS stale >60s ‚Äî forcing reconnect");
          try { ws.close(); } catch {}
          clearInterval(guard);
        }
      }, 5000);
    }
    connectWS();
    setInterval(catchUpPending, 10_000);


    // twardy reload co 30 min (nie w trybie edycji)
    if (!OBS_EDIT_MODE) {
      setInterval(() => {
        location.reload();
      }, hardReloadEveryMs);
    }

    // awaryjny reload gdy d≈Çugo nie mamy sygna≈Çu i /health nie dzia≈Ça
    setInterval(async () => {
      if (OBS_EDIT_MODE) return;
      if (Date.now() - lastSignalAt < staleKickMs * 2) return;
      try {
        const r = await fetch('/health', { cache:'no-store' });
        if (!r.ok) throw 0;
      } catch {
        console.warn("Health check failed ‚Äî reloading page");
        location.reload();
      }
    }, 20_000);

    canvas.addEventListener("click", () => { queue.push(1); showOverlay(); runQueue(); });

    // ====== Editor ======
    const editor=document.getElementById("editor");
    const listEl=document.getElementById("list");
    const newLabel=document.getElementById("newLabel");
    const newWeight=document.getElementById("newWeight");
    const addBtn=document.getElementById("addBtn");
    const saveBtn=document.getElementById("saveBtn");
    const resetBtn=document.getElementById("resetBtn");
    const hideBtn=document.getElementById("hideBtn");
    const normalizeBtn=document.getElementById("normalizeBtn");
    const exportBtn=document.getElementById("exportBtn");
    const importBtn=document.getElementById("importBtn");
    const importArea=document.getElementById("importArea");
    const sumInfo=document.getElementById("sumInfo");
    const adminKeyInput=document.getElementById("adminKey");
    const saveKeyBtn=document.getElementById("saveKeyBtn");
    const loadCfgBtn=document.getElementById("loadCfgBtn");

    saveKeyBtn.onclick = ()=>{ localStorage.setItem("ADMIN_KEY", adminKeyInput.value.trim()); alert("Admin key saved locally."); };
    loadCfgBtn.onclick = async ()=> {
      const s = await fetchServerConfig();
      if (s && s.length >= 0) {
        ITEMS = s.map(sanitizeItem);
        CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag();
        alert("Loaded from server.");
      } else {
        alert("No server config (using local/default).");
      }
    };

    function totalWeight(){ return ITEMS.reduce((s,x)=> s + Math.max(0, Number(x.weight)||0), 0); }
    function sumWeights(){ return totalWeight(); }

    function renderList(){
      listEl.innerHTML="";
      sumInfo.textContent=`Sum of weights: ${sumWeights().toFixed(2)}%`;
      ITEMS.forEach((it,i)=>{
        const row=document.createElement("div"); row.className="item";
        const name=document.createElement("span"); name.textContent=it.label;
        const weight=document.createElement("input"); weight.type="number"; weight.min="0"; weight.step="0.1";
        weight.value=Number(it.weight).toFixed(2); weight.title="Percent (weight)";
        weight.onchange=()=>{ let v=Number(weight.value); if(!Number.isFinite(v)||v<0) v=0;
          ITEMS[i].weight=v; CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); };

        const up=document.createElement("button"); up.textContent="‚Üë";
        up.onclick=()=>{ if(i>0){ [ITEMS[i-1],ITEMS[i]]=[ITEMS[i],ITEMS[i-1]]; CONFIG_VERSION++; renderList();
          if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); } };

        const down=document.createElement("button"); down.textContent="‚Üì";
        down.onclick=()=>{ if(i<ITEMS.length-1){ [ITEMS[i+1],ITEMS[i]]=[ITEMS[i],ITEMS[i+1]]; CONFIG_VERSION++; renderList();
          if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); } };

        const edit=document.createElement("button"); edit.textContent="‚úé";
        edit.onclick=()=>{ const v=prompt("Rename prize:", ITEMS[i].label);
          if(v!==null){ const s=v.trim(); if(s){ ITEMS[i].label=s; CONFIG_VERSION++; renderList();
            if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); } } };

        const del=document.createElement("button"); del.textContent="‚úï";
        del.onclick=()=>{
          if (ITEMS.length <= 1) { alert("At least one prize must remain."); return; }
          ITEMS.splice(i,1); CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag();
        };

        row.appendChild(name); row.appendChild(weight); row.appendChild(up); row.appendChild(down); row.appendChild(edit); row.appendChild(del);
        listEl.appendChild(row);
      });
    }

    addBtn.onclick=()=>{ const label=(newLabel.value||"").trim(); let w=Number(newWeight.value);
      if(!label) return; if(!Number.isFinite(w)||w<0) w=0;
      ITEMS.push({id:genId(), label, weight:w}); CONFIG_VERSION++; newLabel.value="";
      renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); };

    saveBtn.onclick=async ()=>{
      const ok = await saveToServer(ITEMS);
      if (ok){ saveItemsLocal(ITEMS); alert("Saved to server."); }
      else { alert("Server save failed (check X-Admin-Key)."); }
      CONFIG_VERSION++; buildSpinBag();
    };

    resetBtn.onclick=()=>{ if(confirm("Restore defaults?")){
      ITEMS=DEFAULT_ITEMS.map(sanitizeItem); CONFIG_VERSION++; renderList();
      if(!ACTIVE_SNAPSHOT) drawWheel(rotation); saveItemsLocal(ITEMS); buildSpinBag(); } };

    hideBtn.onclick=()=> editor.classList.toggle("show", false);

    normalizeBtn.onclick=()=>{ const sum=sumWeights();
      if(sum<=0){ const eq=ITEMS.length?(100/ITEMS.length):0; ITEMS=ITEMS.map(it=>({...it, weight:eq})); }
      else { ITEMS=ITEMS.map(it=>({...it, weight:(it.weight/sum)*100 })); }
      CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); };

    exportBtn.onclick=()=>{ importArea.value=JSON.stringify(ITEMS,null,2); importArea.focus(); importArea.select(); };
    importBtn.onclick=()=>{ try{
        const arr=JSON.parse(importArea.value);
        if(Array.isArray(arr) && arr.length){
          ITEMS=arr.map(sanitizeItem);
        } else if (Array.isArray(arr) && arr.length===0) {
          ITEMS=[];
        } else {
          alert("Invalid JSON format."); return;
        }
        CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag();
      }catch{ alert("Invalid JSON."); } };

    function toggleEditor(show){ editor.classList.toggle("show", !!show); editor.setAttribute("aria-hidden", show?"false":"true"); }

    (async function boot(){
      const p = new URLSearchParams(location.search);
      if (p.get("edit") === "1") toggleEditor(true);

      // 1st try server config; fallback local/default
      const fromServer = await fetchServerConfig();
      if (fromServer && fromServer.length >= 0) {
        ITEMS = Array.isArray(fromServer) ? fromServer.map(sanitizeItem) : loadItemsLocal();
        if (fromServer.length === 0) console.warn("Server config is empty.");
      } else {
        ITEMS = loadItemsLocal();
      }

      // preload admin key field (local, only on your machine)
      adminKeyInput.value = localStorage.getItem("ADMIN_KEY") || "";

      CONFIG_VERSION++; renderList(); buildSpinBag(); drawWheel(0);
    })();
  </script>
</body>
</html>
