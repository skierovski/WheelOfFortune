<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Wheel of Fortune</title>
  <style>
    html, body { margin:0; padding:0; background:transparent; overflow:hidden; }
    .overlay { position: fixed; left:50%; top:50%; transform: translate(-50%, -40%) scale(0.94);
      opacity: 0; transition: opacity .95s ease, transform .95s ease; pointer-events:none; width:700px; height:700px;
      display:flex; align-items:center; justify-content:center; z-index:10; }
    .overlay.show { opacity:1; transform: translate(-50%, -50%) scale(1); pointer-events:auto; }
    canvas { width:1000px; height:1000px; display:block; }

    .editor { position:fixed; right:16px; top:16px; width:460px; max-height:92vh; overflow:auto; background:rgba(20,20,20,.95); color:#fff;
      font-family:system-ui,sans-serif; border-radius:12px; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.08);
      z-index:9999; display:none; }
    .editor.show { display:block; }
    .editor h2{ margin:0 0 10px 0; font-size:18px; }
    .row{ display:flex; gap:8px; margin-bottom:8px; align-items:center; }
    .row input[type="text"]{ flex:1; padding:8px 10px; border-radius:8px; border:1px solid #333; background:#141414; color:#fff; }
    .row input[type="number"]{ width:84px; padding:8px 10px; border-radius:8px; border:1px solid #333; background:#141414; color:#fff; }
    .row button, .editor .btn { padding:8px 10px; border-radius:8px; border:1px solid #333; background:#1f1f1f; color:#fff; cursor:pointer; }
    .list{ display:grid; gap:6px; margin:10px 0; }
    .item{ display:grid; grid-template-columns:1fr 80px 98px auto auto auto auto; gap:6px; align-items:center; background:#151515; border:1px solid #2a2a2a; border-radius:8px; padding:8px; }
    .item span{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .muted{ color:#9aa0a6; font-size:12px; }
    .pill{ display:inline-block; padding:4px 8px; border-radius:999px; background:#0f172a; border:1px solid #334155; color:#cbd5e1; font-size:12px; }

    .result-banner { position: absolute; left: 50%; top: 8%; transform: translate(-50%, -20%) scale(0.95); opacity: 0; padding: 14px 22px;
      border-radius: 14px; background: rgba(17, 17, 17, 0.80); color: #fff; font-family: system-ui, sans-serif; font-weight: 800; letter-spacing: .3px;
      line-height: 1; font-size: 48px; box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08); backdrop-filter: blur(6px);
      pointer-events: none; z-index: 20; transition: opacity .35s ease, transform .35s ease; }
    .result-banner.show { opacity: 1; transform: translate(-50%, 0) scale(1); }
    .bonus-badge{ font-size:14px; margin-left:8px; padding:4px 8px; background:#14532d; border:1px solid #166534; color:#bbf7d0; border-radius:999px; vertical-align:middle; }
  </style>
</head>
<body>
  <div id="resultBanner" class="result-banner" aria-hidden="true"></div>
  <div id="overlay" class="overlay">
    <canvas id="wheel" width="1000" height="1000"></canvas>
  </div>

  <!-- SFX/TTS -->
  <audio id="sfx" preload="auto"></audio>

  <!-- Admin/editor panel -->
  <div id="editor" class="editor" aria-hidden="true">
    <h2>üéõÔ∏è Wheel editor <span class="pill">open via ?edit=1</span></h2>
    <div class="muted">Server-backed config. Viewers do not see this panel.</div>

    <div class="row" style="margin-top:6px;">
      <input id="newLabel" type="text" placeholder="New prize‚Ä¶">
      <input id="newWeight" type="number" min="0" step="0.1" value="10" title="Percent">
      <label class="muted" style="display:flex;align-items:center;gap:6px;">
        <input id="newBonus" type="checkbox"> Bonus spin
      </label>
      <button id="addBtn">Add</button>
    </div>
    <div class="muted" id="sumInfo"></div>
    <div class="list" id="list"></div>
    <div class="bar">
      <button class="btn" id="normalizeBtn">Normalize to 100%</button>
      <button class="btn" id="saveBtn">Save (server)</button>
      <button class="btn" id="resetBtn">Reset</button>
      <button class="btn" id="hideBtn">Close</button>
      <button class="btn" id="exportBtn">Export</button>
      <button class="btn" id="importBtn">Import</button>
    </div>
    <textarea id="importArea" placeholder='Paste JSON here (from "Export") and click "Import".'></textarea>

    <div class="row" style="margin-top:10px;">
      <input id="adminKey" type="text" placeholder="X-Admin-Key (only for editor owner)">
      <button id="saveKeyBtn" class="btn">Save Key</button>
      <button id="loadCfgBtn" class="btn">Load</button>
    </div>
  </div>

  <script>
    // ====== Server config helpers ======
    async function fetchServerConfigFull() {
      try {
        const r = await fetch("/config", { cache: "no-store" });
        if (!r.ok) return null;
        const j = await r.json();
        return j?.ok ? j : null;
      } catch { return null; }
    }
    async function saveToServer(items, theme) {
      const key = localStorage.getItem("ADMIN_KEY") || "";
      const r = await fetch("/config", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Admin-Key": key },
        body: JSON.stringify({ items, theme })
      });
      return r.ok;
    }

    // ====== Data / persistence (local cache only) ======
    const STORAGE_KEY_V2 = "wheel.prizes.v2";
    const DEFAULT_ITEMS = [
      { label:"VIP na 24h", weight:10, bonus:false }, { label:"≈öpiewasz 30s", weight:10, bonus:false },
      { label:"Mem na IG", weight:10, bonus:false },  { label:"Reroll", weight:10, bonus:false },
      { label:"Wyb√≥r czatu", weight:10, bonus:false },{ label:"Shot (18+)", weight:10, bonus:false },
      { label:"Giveaway 1x", weight:10, bonus:false },{ label:"Wyb√≥r mapy", weight:10, bonus:false }
    ];

    function genId(){ return 'itm_' + Math.random().toString(36).slice(2,10) + Date.now().toString(36); }
    function sanitizeItem(it){
      const label = String(it?.label ?? "").trim();
      let weight = Number(it?.weight);
      if (!Number.isFinite(weight) || weight < 0) weight = 0;
      const id = String(it?.id || "");
      const bonus = !!it?.bonus;
      return { id: id || genId(), label, weight, bonus };
    }
    function loadItemsLocal(){
      try{
        const raw=localStorage.getItem(STORAGE_KEY_V2);
        if(raw){ const arr=JSON.parse(raw); if(Array.isArray(arr)&&arr.length) return arr.map(sanitizeItem); }
      }catch{}
      return DEFAULT_ITEMS.map(sanitizeItem);
    }
    function saveItemsLocal(items){ localStorage.setItem(STORAGE_KEY_V2, JSON.stringify(items.map(sanitizeItem))); }

    let ITEMS = [];
    let CONFIG_VERSION = 1;
    let THEME = "wood"; // default theme; can be overridden by server/URL

    // ====== Drawing etc. ======
    const COLORS = ["#FF4D4F","#40A9FF","#73D13D","#FAAD14","#9254DE","#13C2C2","#EB2F96","#A0D911","#FFD666","#5CDBD3","#FF7A45","#597EF7"];
    const FULL_ROUNDS_MIN = 5, FULL_ROUNDS_MAX = 7;
    const BAG_SIZE = 50;
    const NO_REPEAT_BACK_TO_BACK = true;
    const AT_LEAST_ONE_THRESHOLD = 1;

    let spinBag = [], bagPos = 0, spinBagVersion = 0, lastPickedId = null, lastIndex = -1;
    const canvas = document.getElementById("wheel");
    const ctx = canvas.getContext("2d");
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio||1));
    (function setupCanvas(){ const cssW=1000, cssH=1000; canvas.width=cssW*dpr; canvas.height=cssH*dpr; canvas.style.width=cssW+"px"; canvas.style.height=cssH+"px"; ctx.setTransform(dpr,0,0,dpr,0,0); })();
    const W=1000,H=1000,CX=W/2,CY=H/2,R=Math.min(W,H)*0.45;
    let rotation = 0;
    let ACTIVE_SNAPSHOT = null;

    function modTau(x){ const TAU = 2*Math.PI; return ((x % TAU) + TAU) % TAU; }
    function getNormalizedWeightsFrom(items){
      const w = items.map(it=>Math.max(0, Number(it.weight)||0));
      const sum = w.reduce((a,b)=>a+b,0);
      if(sum<=0){ const eq=100/Math.max(1,items.length); return w.map(()=>eq); }
      return w.map(x=>x*(100/sum));
    }
    function buildSectors(items){
      const pct = getNormalizedWeightsFrom(items);
      const sectors = []; let acc=0;
      for(let i=0;i<items.length;i++){
        const startPct=acc, endPct=acc+pct[i]; acc=endPct;
        const start=(startPct/100)*2*Math.PI, end=(endPct/100)*2*Math.PI;
        sectors.push({ id:items[i].id, label:items[i].label, start, end, center:(start+end)/2, bonus: !!items[i].bonus });
      }
      return sectors;
    }
    function shuffleInPlace(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
    function cloneItems(items){ return items.map(it=>({ id:it.id, label:it.label, weight:it.weight, bonus:!!it.bonus })); }

    function sectorUnderPointer(angle, sectors){
      const POINTER_ANGLE = -Math.PI/2;
      const rel = modTau(POINTER_ANGLE - modTau(angle));
      for (let i = 0; i < sectors.length; i++){
        const a = modTau(sectors[i].start), b = modTau(sectors[i].end);
        if (a <= b) { if (rel >= a && rel < b) return i; } else { if (rel >= a || rel < b) return i; }
      }
      return 0;
    }

    // ===== Helpers: text/arc =====
    function fitFontForArc(ctx, text, radius, arcAngle, maxPx = 42, minPx = 10) {
      const maxLen = radius * arcAngle * 0.9;
      let lo = minPx, hi = maxPx, best = minPx;
      while (lo <= hi) {
        const mid = (lo + hi) >> 1;
        ctx.font = `700 ${mid}px system-ui, sans-serif`;
        const w = ctx.measureText(text).width;
        if (w <= maxLen) { best = mid; lo = mid + 1; } else { hi = mid - 1; }
      }
      ctx.font = `700 ${best}px system-ui, sans-serif`;
      return best;
    }
    function ellipsize(ctx, text, maxWidth) {
      if (ctx.measureText(text).width <= maxWidth) return text;
      const ell = "‚Ä¶"; let s = text;
      while (s.length > 1 && ctx.measureText(s + ell).width > maxWidth) s = s.slice(0, -1);
      return s + ell;
    }

    // ===== Theme router =====
    function drawWheel(angle = 0) {
      if (THEME === "classic") return drawWheelClassic(angle);
      return drawWheelWood(angle);
    }

    // ===== Wood theme (as-is) =====
    function drawWheelWood(angle = 0) {
      const items = ACTIVE_SNAPSHOT || ITEMS;
      ctx.clearRect(0, 0, W, H);

      // ring
      ctx.beginPath();
      ctx.arc(CX, CY, R + 44, 0, 2 * Math.PI);
      ctx.fillStyle = "#deb887";
      ctx.fill();
      ctx.lineWidth = 10;
      ctx.strokeStyle = "#8b5a2b";
      ctx.stroke();

      if (!items || items.length === 0) {
        const hubR0 = Math.max(22, R * 0.42);
        ctx.beginPath();
        ctx.arc(CX, CY, hubR0, 0, 2 * Math.PI);
        const hubGrad0 = ctx.createRadialGradient(CX, CY, 4, CX, CY, hubR0);
        hubGrad0.addColorStop(0, "#f1c27d");
        hubGrad0.addColorStop(1, "#8b5a2b");
        ctx.fillStyle = hubGrad0;
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#5e3d1e";
        ctx.stroke();

        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.moveTo(CX, CY - R - 16);
        ctx.lineTo(CX - 18, CY - R + 14);
        ctx.lineTo(CX + 18, CY - R + 14);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.arc(CX, CY, R + 6, 0, 2 * Math.PI);
        ctx.strokeStyle = "rgba(255,255,255,.35)";
        ctx.lineWidth = 4;
        ctx.stroke();
        return;
      }

      const sectors = buildSectors(items);

      for (let i = 0; i < sectors.length; i++) {
        const s = sectors[i];
        const start = angle + s.start;
        const end   = angle + s.end;
        const arcAngle = end - start;

        ctx.beginPath();
        ctx.moveTo(CX, CY);
        ctx.arc(CX, CY, R, start, end);
        ctx.closePath();

        const grad = ctx.createRadialGradient(CX, CY, R * 0.08, CX, CY, R);
        grad.addColorStop(0, COLORS[i % COLORS.length]);
        grad.addColorStop(1, COLORS[(i + 1) % COLORS.length]);
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,.6)";
        ctx.lineWidth = 2;
        ctx.stroke();

        const mid = start + arcAngle / 2;
        const rText = R * 0.72;
        const rawLabel = String(s.label || "");
        const fontPx = fitFontForArc(ctx, rawLabel, rText, arcAngle, 42, 10);
        ctx.font = `700 ${fontPx}px system-ui, sans-serif`;
        const maxLen = rText * arcAngle * 0.9;
        const label = ellipsize(ctx, rawLabel, maxLen);

        const tx = CX + Math.cos(mid) * rText;
        const ty = CY + Math.sin(mid) * rText;
        ctx.save();
        ctx.translate(tx, ty);
        ctx.rotate(mid + Math.PI / 2);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.lineWidth = Math.max(2, Math.round(fontPx * 0.12));
        ctx.strokeStyle = "rgba(0,0,0,0.55)";
        ctx.fillStyle = "#fff";
        ctx.shadowColor = "rgba(0,0,0,0.25)";
        ctx.shadowBlur = fontPx * 0.35;
        ctx.strokeText(label, 0, 0);
        ctx.fillText(label, 0, 0);
        ctx.restore();
      }

      const hubR = Math.max(22, R * 0.42);
      ctx.beginPath();
      ctx.arc(CX, CY, hubR, 0, 2 * Math.PI);
      const hubGrad = ctx.createRadialGradient(CX, CY, 4, CX, CY, hubR);
      hubGrad.addColorStop(0, "#f1c27d");
      hubGrad.addColorStop(1, "#8b5a2b");
      ctx.fillStyle = hubGrad;
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#5e3d1e";
      ctx.stroke();

      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.moveTo(CX, CY - R - 16);
      ctx.lineTo(CX - 18, CY - R + 14);
      ctx.lineTo(CX + 18, CY - R + 14);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.arc(CX, CY, R + 6, 0, 2 * Math.PI);
      ctx.strokeStyle = "rgba(255,255,255,.35)";
      ctx.lineWidth = 4;
      ctx.stroke();

      ctx.fillStyle = "#8B5A2B";
      ctx.fillRect(CX - 55, CY + R + 12, 110, 115);
      ctx.fillStyle = "#6f451d";
      ctx.fillRect(CX - 130, CY + R + 120, 260, 28);
    }

    // ===== Classic theme (metal/rivets/glass) ‚Äî bez halo poza ko≈Çem =====
    function drawWheelClassic(angle = 0) {
      const items = ACTIVE_SNAPSHOT || ITEMS;
      ctx.clearRect(0, 0, W, H);

      const rimOuter = R + 42;
      ctx.beginPath(); ctx.arc(CX, CY, rimOuter, 0, 2*Math.PI);
      const metal = ctx.createRadialGradient(CX, CY, R, CX, CY, rimOuter);
      metal.addColorStop(0, "#d9dee5");
      metal.addColorStop(0.5, "#8f99a8");
      metal.addColorStop(1, "#e9eef5");
      ctx.fillStyle = metal; ctx.fill();

      const rimInnerOut = R + 22, rimInnerIn = R + 6;
      ctx.beginPath(); ctx.arc(CX, CY, rimInnerOut, 0, 2*Math.PI);
      ctx.arc(CX, CY, rimInnerIn, 0, 2*Math.PI, true);
      const metal2 = ctx.createLinearGradient(CX-R, CY-R, CX+R, CY+R);
      metal2.addColorStop(0, "#cfd6df");
      metal2.addColorStop(0.5, "#7c8798");
      metal2.addColorStop(1, "#dfe6ef");
      ctx.fillStyle = metal2; ctx.fill();

      const rivets = Math.max(12, Math.floor((R*2*Math.PI)/90));
      for (let i=0;i<rivets;i++){
        const a = (i/rivets)*2*Math.PI;
        const rx = CX + Math.cos(a)*(R+14);
        const ry = CY + Math.sin(a)*(R+14);
        ctx.beginPath();
        const rg = ctx.createRadialGradient(rx, ry, 1, rx, ry, 6);
        rg.addColorStop(0, "#ffffff");
        rg.addColorStop(1, "#4b5563");
        ctx.fillStyle = rg;
        ctx.arc(rx, ry, 6, 0, 2*Math.PI);
        ctx.fill();
      }

      if (!items || items.length === 0) {
        const hubR0 = Math.max(22, R * 0.42);
        ctx.beginPath(); ctx.arc(CX, CY, hubR0, 0, 2*Math.PI);
        const glass = ctx.createRadialGradient(CX-8, CY-8, 4, CX, CY, hubR0);
        glass.addColorStop(0, "#ffffff");
        glass.addColorStop(1, "#90a4c4");
        ctx.fillStyle = glass; ctx.fill();
        ctx.lineWidth = 3; ctx.strokeStyle = "#6b7280"; ctx.stroke();

        ctx.fillStyle = "#d1d5db";
        ctx.beginPath();
        ctx.moveTo(CX, CY - R - 18);
        ctx.lineTo(CX - 20, CY - R + 10);
        ctx.lineTo(CX + 20, CY - R + 10);
        ctx.closePath(); ctx.fill();
        ctx.strokeStyle = "#6b7280"; ctx.lineWidth = 2; ctx.stroke();

        ctx.beginPath(); ctx.arc(CX, CY, R + 6, 0, 2*Math.PI);
        ctx.strokeStyle = "rgba(255,255,255,.45)"; ctx.lineWidth = 3; ctx.stroke();
        return;
      }

      const sectors = buildSectors(items);
      const baseColors = ["#FF3B3B","#1E90FF","#2ED573","#FFC107","#A55EEA","#17A2B8","#FF6B6B","#7bed9f","#FFD166","#74C0FC","#FFA94D","#748FFC"];

      for (let i=0;i<sectors.length;i++){
        const s = sectors[i];
        const start = angle + s.start, end = angle + s.end;
        const arcAngle = end - start;

        ctx.beginPath();
        ctx.moveTo(CX, CY);
        ctx.arc(CX, CY, R, start, end);
        ctx.closePath();

        const segGrad = ctx.createRadialGradient(CX, CY, R*0.2, CX, CY, R);
        segGrad.addColorStop(0, baseColors[i % baseColors.length]);
        segGrad.addColorStop(1, "#1f2937");
        ctx.fillStyle = segGrad; ctx.fill();

        ctx.strokeStyle = "rgba(255,255,255,.65)";
        ctx.lineWidth = 1.5; ctx.stroke();

        const mid = start + arcAngle/2, rText = R*0.72;
        const raw = String(s.label||"");
        const fontPx = fitFontForArc(ctx, raw, rText, arcAngle, 40, 10);
        ctx.font = `800 ${fontPx}px system-ui, sans-serif`;
        const maxLen = rText * arcAngle * 0.9;
        const label = ellipsize(ctx, raw, maxLen);

        const tx = CX + Math.cos(mid)*rText;
        const ty = CY + Math.sin(mid)*rText;
        ctx.save();
        ctx.translate(tx, ty);
        ctx.rotate(mid + Math.PI/2);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.lineWidth = Math.max(2, Math.round(fontPx * 0.12));
        ctx.strokeStyle = "rgba(0,0,0,0.55)";
        ctx.fillStyle = "#fff";
        ctx.shadowBlur = 0;
        ctx.strokeText(label, 0, 0);
        ctx.fillText(label, 0, 0);
        ctx.restore();
      }

      const hubR = Math.max(22, R * 0.42);
      ctx.beginPath(); ctx.arc(CX, CY, hubR, 0, 2*Math.PI);
      const glass2 = ctx.createRadialGradient(CX-10, CY-12, 6, CX, CY, hubR);
      glass2.addColorStop(0, "#ffffff");
      glass2.addColorStop(1, "#90a4c4");
      ctx.fillStyle = glass2; ctx.fill();
      ctx.lineWidth = 2.5; ctx.strokeStyle = "#9aa3b2"; ctx.stroke();

      ctx.fillStyle = "#d1d5db";
      ctx.beginPath();
      ctx.moveTo(CX, CY - R - 18);
      ctx.lineTo(CX - 20, CY - R + 10);
      ctx.lineTo(CX + 20, CY - R + 10);
      ctx.closePath(); ctx.fill();
      ctx.strokeStyle = "#6b7280"; ctx.lineWidth = 2; ctx.stroke();

      ctx.beginPath(); ctx.arc(CX, CY, R + 6, 0, 2*Math.PI);
      ctx.strokeStyle = "rgba(255,255,255,.45)"; ctx.lineWidth = 3; ctx.stroke();

      ctx.fillStyle = "#0f1115";
      ctx.fillRect(CX - 55, CY + R + 12, 110, 12);
    }

    function getNormalizedWeights(){ return getNormalizedWeightsFrom(ITEMS); }

    function buildSpinBag(){
      const L = ITEMS.length;
      if (L === 0) {
        spinBag = [];
        bagPos = 0;
        spinBagVersion = CONFIG_VERSION;
        console.log("üß∞ Bag skipped (no items).");
        return;
      }

      const n = L;
      const norm = getNormalizedWeights();
      const desired = norm.map(p=>p*BAG_SIZE/100);

      let counts=new Array(n).fill(0), assigned=0, residuals=new Array(n).fill(0);
      for (let i=0;i<n;i++){ counts[i]=Math.floor(desired[i]); assigned+=counts[i]; residuals[i]=desired[i]-Math.floor(desired[i]); }
      for (let i=0;i<n;i++){ if (norm[i]>=AT_LEAST_ONE_THRESHOLD && counts[i]===0){ counts[i]++; assigned++; } }

      const byResidualDesc=[...Array(n).keys()].sort((a,b)=>residuals[b]-residuals[a]);
      const byResidualAsc=[...Array(n).keys()].sort((a,b)=>residuals[a]-residuals[b]);
      const byPctAsc=[...Array(n).keys()].sort((a,b)=>norm[a]-norm[b]);

      while(assigned<BAG_SIZE){ for(let k=0;k<n && assigned<BAG_SIZE;k++){ counts[byResidualDesc[k]]++; assigned++; } }
      if(assigned>BAG_SIZE){
        let iA=0,iB=0;
        while(assigned>BAG_SIZE && (iA<n || iB<n)){
          const i = (iA<n) ? byResidualAsc[iA++] : byPctAsc[iB++];
          if (counts[i]>0 && !(norm[i]>=AT_LEAST_ONE_THRESHOLD && counts[i]===1)){ counts[i]--; assigned--; }
        }
      }

      const bag=[];
      for (let i=0;i<n;i++){
        const id = ITEMS[i].id ?? (ITEMS[i].id = genId());
        for(let c=0;c<counts[i];c++) bag.push(id);
      }
      shuffleInPlace(bag);
      spinBag=bag; bagPos=0; spinBagVersion=CONFIG_VERSION;
      const dbg = counts.map((c,i)=>`${ITEMS[i]?.label||i}:${c}`).join(" | ");
      console.log(`üß∞ Bag built (${BAG_SIZE}):`, dbg);
    }

    function nextFromBag(){
      if(!spinBag || bagPos>=spinBag.length || spinBagVersion!==CONFIG_VERSION) buildSpinBag();
      if (spinBag.length === 0) { console.warn("Spin requested but no items."); return null; }
      let pickedId = spinBag[bagPos++];
      if (NO_REPEAT_BACK_TO_BACK && lastPickedId===pickedId && spinBag.length>1){
        if (bagPos<spinBag.length && spinBag[bagPos]!==lastPickedId){ const alt=spinBag[bagPos]; spinBag[bagPos]=pickedId; pickedId=alt; }
        else { for(let i=bagPos;i<spinBag.length;i++){ if (spinBag[i]!==lastPickedId){ const alt=spinBag[i]; spinBag[i]=pickedId; pickedId=alt; break; } } }
      }
      lastPickedId=pickedId;
      return pickedId;
    }

    function easeOutQuint(t){ return 1 - Math.pow(1 - t, 5); }

    async function spinToId(pickedId){
      if (!pickedId) return { index:-1, snap:null, label:"", bonus:false };
      ACTIVE_SNAPSHOT = cloneItems(ITEMS);
      const SNAP = ACTIVE_SNAPSHOT; const sectors = buildSectors(SNAP);
      let pickedIdx = sectors.findIndex(s => s.id === pickedId);
      if (pickedIdx === -1) pickedIdx = 0;
      const picked = sectors[pickedIdx];

      const POINTER_ANGLE = -Math.PI/2; const TAU = 2*Math.PI;
      const startAngle = modTau(rotation); let baseTarget = POINTER_ANGLE - picked.center;

      while (baseTarget <= startAngle) baseTarget += TAU;
      const roundsInt = Math.floor(FULL_ROUNDS_MIN + Math.random()*(FULL_ROUNDS_MAX - FULL_ROUNDS_MIN + 1));
      const targetAngle = baseTarget + Math.max(FULL_ROUNDS_MIN, roundsInt) * TAU;

      const totalDuration = 5200; const t0 = performance.now();

      return new Promise(resolve=>{
        function frame(t){
          const p = Math.min(1, (t - t0) / totalDuration);
          const eased = easeOutQuint(p);
          rotation = startAngle + (targetAngle - startAngle) * eased;
          drawWheel(rotation);
          if (p < 1) requestAnimationFrame(frame);
          else {
            rotation = targetAngle;
            drawWheel(rotation);
            const winIdx = sectorUnderPointer(rotation, sectors);
            const winSec = sectors[winIdx];
            const bonus = !!winSec.bonus;
            lastIndex = pickedIdx;
            setTimeout(()=>{ ACTIVE_SNAPSHOT = null; }, 0);
            resolve({ index: winIdx, snap: SNAP, label: winSec.label, bonus });
          }
        }
        requestAnimationFrame(frame);
      });
    }

    const overlay = document.getElementById("overlay");
    const queue = []; let spinning=false; let hideTimer=null;
    function showOverlay(){ clearTimeout(hideTimer); overlay.classList.add("show"); }
    function hideOverlay(afterMs = 1600) {
      clearTimeout(hideTimer);
      hideTimer = setTimeout(()=>{ overlay.classList.remove("show"); hideResult(); }, afterMs);
    }

    const resultBanner = document.getElementById("resultBanner");
    let resultTimer = null;
    function showResult(label, ms = 1800, isBonus = false) {
      if (!resultBanner) return;
      clearTimeout(resultTimer);
      resultBanner.innerHTML = isBonus
        ? `${label} <span class="bonus-badge">+ bonus spin</span>`
        : label || "";
      resultBanner.classList.add("show");
      resultBanner.setAttribute("aria-hidden", "false");
      resultTimer = setTimeout(hideResult, ms);
    }
    function hideResult() {
      if (!resultBanner) return;
      resultBanner.classList.remove("show");
      resultBanner.setAttribute("aria-hidden", "true");
    }

    function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }

    // ====== SFX / TTS ======
    const urlp = new URLSearchParams(location.search);
    const SND_URL = urlp.get("sound") || "";   // ?sound=/sounds/ding.mp3
    const USE_TTS = urlp.get("tts") === "1";   // ?tts=1
    const sfx = document.getElementById("sfx");
    if (SND_URL) sfx.src = SND_URL;

    function playSound(){ try{ if (SND_URL) { sfx.currentTime = 0; sfx.play().catch(()=>{}); } }catch{} }
    function speak(text){
      if (!USE_TTS || !("speechSynthesis" in window)) return;
      try {
        const u = new SpeechSynthesisUtterance(String(text||""));
        u.rate=1; u.pitch=1; u.lang="pl-PL";
        speechSynthesis.cancel(); speechSynthesis.speak(u);
      } catch {}
    }

    async function runQueue(){
      if (spinning) return;
      spinning=true;
      if (queue.length){ showOverlay(); await wait(400); }
      while (queue.length) {
        const pickedId = nextFromBag();
        const result = await spinToId(pickedId);
        if (result.label) {
          console.log(`‚úÖ [${bagPos}/${spinBag.length}] ${result.label} ${result.bonus ? '(bonus)' : ''}`);
          showResult(result.label, 1800, result.bonus);
          playSound();
          speak(result.label);

          // BONUS: dok≈Çadamy jedno ekstra zakrƒôcenie
          if (result.bonus) {
            queue.push(1);
          }

          fetch('/chat/announce', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ label: result.label + (result.bonus ? " (+bonus)" : "") })
          }).catch(()=>{});
        }
        queue.shift();
        await wait(2000);
        
        // Notify server after EACH spin completes (not just at the end)
        // This ensures 5-minute delay between each spin, even if multiple are queued
        fetch('/spins/complete', { method: 'POST' }).catch(()=>{});
      }
      spinning=false;
      hideOverlay(1000);
    }

    // ====== WebSocket & watchdog ======
    const OBS_EDIT_MODE = new URLSearchParams(location.search).get("edit") === "1";
    const WS_URL = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws';

    let ws = null;
    let reconnectDelay = 1000;
    let lastSignalAt = Date.now();
    const staleKickMs = 60_000;
    const hardReloadEveryMs = 30 * 60_000;

    function handleServerMessage(data) {
      if (data.type === "config" && Array.isArray(data.items)) {
        ITEMS = data.items.map(sanitizeItem);
        if (typeof data.theme === "string") THEME = data.theme;
        CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag();
        return;
      }
      if (data.action === "spin" && Number.isFinite(data.times)) {
        // Server always sends 1 spin at a time to respect delays
        console.log("[WS] üì• Received spin command");
        queue.push(1);
        showOverlay(); runQueue(); return;
      }
    }

    // HTTP polling fallback - ensures we don't miss spins if WebSocket fails
    let lastWsMessageTime = Date.now();
    async function checkForMissedSpins() {
      // Only poll if WebSocket seems dead (no messages for 10 seconds) or not connected
      const timeSinceLastMessage = Date.now() - lastWsMessageTime;
      const wsConnected = ws && ws.readyState === WebSocket.OPEN;
      
      if (!wsConnected || timeSinceLastMessage > 10000) {
        // WebSocket might be dead - check server directly
        console.log("[HTTP POLL] Checking server (WS inactive)...");
        try {
          const r = await fetch('/spins/pending', { cache: 'no-store' });
          const j = await r.json();
          const pending = Math.max(0, Number(j?.count || 0));
          const timeUntilNext = Math.max(0, Number(j?.timeUntilNext || 0));
          
          // If server says spin is ready but we haven't spun, we missed the WS message
          if (pending > 0 && timeUntilNext === 0 && queue.length === 0 && !spinning) {
            console.log("[HTTP POLL] ‚úÖ Found ready spin (missed WS) - triggering!");
            queue.push(1);
            showOverlay();
            runQueue();
          }
        } catch (e) {
          console.error("[HTTP POLL] Failed:", e);
        }
      }
    }

    function connectWS() {
      try { if (ws) ws.close(); } catch {}
      ws = new WebSocket(WS_URL);

      ws.onopen = async () => {
        console.log("[WS] ‚úÖ Connected");
        lastSignalAt = Date.now();
        lastWsMessageTime = Date.now();
        reconnectDelay = 1000;
        // Check immediately if we missed any spins while disconnected
        checkForMissedSpins();
      };
      ws.onmessage = async (evt) => {
        lastSignalAt = Date.now();
        lastWsMessageTime = Date.now();
        try { handleServerMessage(JSON.parse(evt.data)); } catch (e) { console.error("Bad WS message", e); }
      };
      ws.onerror = (e) => { 
        console.warn("[WS] ‚ö†Ô∏è Error - will reconnect");
        try { ws.close(); } catch {} 
      };
      ws.onclose = () => {
        console.log("[WS] ‚ùå Closed - reconnecting in", Math.ceil(reconnectDelay/1000), "s");
        const wait = reconnectDelay;
        reconnectDelay = Math.min(reconnectDelay * 1.8, 15000);
        setTimeout(connectWS, wait);
      };

      const guard = setInterval(() => {
        if (!ws || ws.readyState !== WebSocket.OPEN) { clearInterval(guard); return; }
        if (Date.now() - lastSignalAt > staleKickMs) {
          console.warn("[WS] ‚è±Ô∏è Stale connection - reconnecting");
          try { ws.close(); } catch {}
          clearInterval(guard);
        }
      }, 5000);
    }
    connectWS();
    
    // HTTP polling fallback - checks every 5 seconds
    setInterval(checkForMissedSpins, 5000);

    if (!OBS_EDIT_MODE) setInterval(() => { location.reload(); }, hardReloadEveryMs);

    setInterval(async () => {
      if (OBS_EDIT_MODE) return;
      if (Date.now() - lastSignalAt < staleKickMs * 2) return;
      try {
        const r = await fetch('/health', { cache:'no-store' });
        if (!r.ok) throw 0;
      } catch { location.reload(); }
    }, 20_000);

    canvas.addEventListener("click", () => { queue.push(1); showOverlay(); runQueue(); });

    // ====== OBS Browser Source Visibility Detection ======
    // Reconnect and check for spins when overlay becomes visible
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) {
        console.log("[OBS] üëÅÔ∏è Overlay visible - reconnecting WS");
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          connectWS();
        } else {
          // Already connected, just check for missed spins
          checkForMissedSpins();
        }
      }
    });

    // OBS-specific activation event
    window.addEventListener("obsSourceActiveChanged", (event) => {
      if (event.detail?.active) {
        console.log("[OBS] üé¨ Source activated - reconnecting WS");
        connectWS();
        checkForMissedSpins();
      }
    });

    // ====== Editor (client-side helper) ======
    const editor=document.getElementById("editor");
    const listEl=document.getElementById("list");
    const newLabel=document.getElementById("newLabel");
    const newWeight=document.getElementById("newWeight");
    const newBonus=document.getElementById("newBonus");
    const addBtn=document.getElementById("addBtn");
    const saveBtn=document.getElementById("saveBtn");
    const resetBtn=document.getElementById("resetBtn");
    const hideBtn=document.getElementById("hideBtn");
    const normalizeBtn=document.getElementById("normalizeBtn");
    const exportBtn=document.getElementById("exportBtn");
    const importBtn=document.getElementById("importBtn");
    const importArea=document.getElementById("importArea");
    const sumInfo=document.getElementById("sumInfo");
    const adminKeyInput=document.getElementById("adminKey");
    const saveKeyBtn=document.getElementById("saveKeyBtn");
    const loadCfgBtn=document.getElementById("loadCfgBtn");

    saveKeyBtn.onclick = ()=>{ localStorage.setItem("ADMIN_KEY", adminKeyInput.value.trim()); alert("Admin key saved locally."); };
    loadCfgBtn.onclick = async ()=> {
      const cfg = await fetchServerConfigFull();
      if (cfg) {
        ITEMS = Array.isArray(cfg.items) ? cfg.items.map(sanitizeItem) : loadItemsLocal();
        if (typeof cfg.theme === "string") THEME = cfg.theme;
        CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag();
        alert("Loaded from server.");
      } else {
        alert("No server config (using local/default).");
      }
    };

    function totalWeight(){ return ITEMS.reduce((s,x)=> s + Math.max(0, Number(x.weight)||0), 0); }
    function sumWeights(){ return totalWeight(); }

    function renderList(){
      listEl.innerHTML="";
      sumInfo.textContent=`Sum of weights: ${sumWeights().toFixed(2)}%  |  Theme: ${THEME}`;
      ITEMS.forEach((it,i)=>{
        const row=document.createElement("div"); row.className="item";

        const name=document.createElement("span"); name.textContent=it.label;

        const weight=document.createElement("input"); weight.type="number"; weight.min="0"; weight.step="0.1";
        weight.value=Number(it.weight).toFixed(2); weight.title="Percent (weight)";
        weight.onchange=()=>{ let v=Number(weight.value); if(!Number.isFinite(v)||v<0) v=0;
          ITEMS[i].weight=v; CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); };

        const bonusWrap = document.createElement("label");
        bonusWrap.style.display="inline-flex"; bonusWrap.style.alignItems="center"; bonusWrap.style.gap="6px";
        bonusWrap.style.userSelect="none"; bonusWrap.title="Bonus: dodatkowe zakrƒôcenie po trafieniu";
        const bonusChk = document.createElement("input"); bonusChk.type="checkbox"; bonusChk.checked=!!it.bonus;
        bonusChk.onchange=()=>{ ITEMS[i].bonus = !!bonusChk.checked; CONFIG_VERSION++; };
        const bonusTxt = document.createElement("span"); bonusTxt.textContent="Bonus spin";
        bonusWrap.appendChild(bonusChk); bonusWrap.appendChild(bonusTxt);

        const up=document.createElement("button"); up.textContent="‚Üë";
        up.onclick=()=>{ if(i>0){ [ITEMS[i-1],ITEMS[i]]=[ITEMS[i],ITEMS[i-1]]; CONFIG_VERSION++; renderList();
          if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); } };

        const down=document.createElement("button"); down.textContent="‚Üì";
        down.onclick=()=>{ if(i<ITEMS.length-1){ [ITEMS[i+1],ITEMS[i]]=[ITEMS[i],ITEMS[i+1]]; CONFIG_VERSION++; renderList();
          if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); } };

        const edit=document.createElement("button"); edit.textContent="‚úé";
        edit.onclick=()=>{ const v=prompt("Rename prize:", ITEMS[i].label);
          if(v!==null){ const s=v.trim(); if(s){ ITEMS[i].label=s; CONFIG_VERSION++; renderList();
            if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); } } };

        const del=document.createElement("button"); del.textContent="‚úï";
        del.onclick=()=>{
          if (ITEMS.length <= 1) { alert("At least one prize must remain."); return; }
          ITEMS.splice(i,1); CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag();
        };

        row.appendChild(name);
        row.appendChild(weight);
        row.appendChild(bonusWrap);
        row.appendChild(up); row.appendChild(down); row.appendChild(edit); row.appendChild(del);
        listEl.appendChild(row);
      });
    }

    addBtn.onclick=()=>{ const label=(newLabel.value||"").trim(); let w=Number(newWeight.value);
      if(!label) return; if(!Number.isFinite(w)||w<0) w=0;
      ITEMS.push({id:genId(), label, weight:w, bonus: !!newBonus.checked}); CONFIG_VERSION++; newLabel.value=""; newBonus.checked=false;
      renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); };

    saveBtn.onclick=async ()=>{ // zapisuje tak≈ºe THEME i bonus
      const ok = await saveToServer(ITEMS, THEME);
      if (ok){ saveItemsLocal(ITEMS); alert("Saved to server."); }
      else { alert("Server save failed (check X-Admin-Key)."); }
      CONFIG_VERSION++; buildSpinBag();
    };

    resetBtn.onclick=()=>{ if(confirm("Restore defaults?")){
      ITEMS=DEFAULT_ITEMS.map(sanitizeItem); CONFIG_VERSION++; renderList();
      if(!ACTIVE_SNAPSHOT) drawWheel(rotation); saveItemsLocal(ITEMS); buildSpinBag(); } };

    hideBtn.onclick=()=> editor.classList.toggle("show", false);

    normalizeBtn.onclick=()=>{ const sum=sumWeights();
      if(sum<=0){ const eq=ITEMS.length?(100/ITEMS.length):0; ITEMS=ITEMS.map(it=>({...it, weight:eq})); }
      else { ITEMS=ITEMS.map(it=>({...it, weight:(it.weight/sum)*100 })); }
      CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag(); };

    exportBtn.onclick=()=>{ importArea.value=JSON.stringify(ITEMS,null,2); importArea.focus(); importArea.select(); };
    importBtn.onclick=()=>{ try{
        const arr=JSON.parse(importArea.value);
        if(Array.isArray(arr)){
          ITEMS=arr.map(sanitizeItem);
        } else {
          alert("Invalid JSON format."); return;
        }
        CONFIG_VERSION++; renderList(); if(!ACTIVE_SNAPSHOT) drawWheel(rotation); buildSpinBag();
      }catch{ alert("Invalid JSON."); } };

    function toggleEditor(show){ editor.classList.toggle("show", !!show); editor.setAttribute("aria-hidden", show?"false":"true"); }

    (async function boot(){
      const p = new URLSearchParams(location.search);
      if (p.get("edit") === "1") toggleEditor(true);

      const cfg = await fetchServerConfigFull();
      if (cfg) {
        if (Array.isArray(cfg.items)) ITEMS = cfg.items.map(sanitizeItem); else ITEMS = loadItemsLocal();
        if (typeof cfg.theme === "string") THEME = cfg.theme;
      } else {
        ITEMS = loadItemsLocal();
      }

      const themeParam = p.get("theme");
      if (themeParam) THEME = themeParam;

      adminKeyInput.value = localStorage.getItem("ADMIN_KEY") || "";

      CONFIG_VERSION++; renderList(); buildSpinBag(); drawWheel(0);
    })();
  </script>
</body>
</html>
