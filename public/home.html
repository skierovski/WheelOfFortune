<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <title>Wheel ‚Äì Home</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, sans-serif; background:#0b0d10; color:#e5e7eb; }
    .wrap { max-width: 980px; margin: 32px auto; padding: 0 16px; }
    h1 { font-size: 24px; margin: 0 0 16px; }
    .grid { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width: 900px){ .grid { grid-template-columns: 1fr 1fr; } }
    .card { background: #111418; border:1px solid #1f2430; border-radius:14px; padding:16px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .btn { padding:8px 12px; border-radius:10px; border:1px solid #2b3242; background:#171b22; color:#e5e7eb; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    code, .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; }
    .ok { color:#22c55e }
    .bad { color:#ef4444 }
    .muted { color:#9aa0a6; font-size: 13px; }
    table { width:100%; border-collapse: collapse; }
    td, th { border-bottom: 1px solid #222835; padding: 8px; text-align: left; vertical-align: middle; }
    .small { font-size: 12px; }
    input[type="text"], input[type="number"] { padding:8px 10px; border-radius:8px; border:1px solid #2b3242; background:#12161c; color:#e5e7eb; }
    input[type="number"] { width:110px; }
    select { padding:8px 10px; border-radius:10px; border:1px solid #2b3242; background:#171b22; color:#e5e7eb; }
    .thumb { width:140px; height:140px; border-radius:12px; background:#0e1116; border:1px solid #202837; display:flex; align-items:center; justify-content:center; }
    canvas.preview { width:140px; height:140px; }
    label.chk { display:inline-flex; align-items:center; gap:8px; user-select:none; }
    input[type="checkbox"] { transform: scale(1.2); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üè† Wheel ‚Äì Home</h1>

    <div class="grid">
      <!-- AUTH / STATUS -->
      <div class="card">
        <h2>üîê Autoryzacja Kick / Status</h2>
        <div id="statusBox" class="muted">≈Åadowanie‚Ä¶</div>
        <div class="row" style="margin-top:10px;">
          <a class="btn" href="/auth/login">üîë Zaloguj przez Kick</a>
          <button class="btn" id="refreshBtn">üîÑ Od≈õwie≈º status</button>
        </div>
      </div>

      <!-- WEBHOOK -->
      <div class="card">
        <h2>üì° Webhook / Subskrypcje</h2>
        <div class="muted">Subskrybuje event: <b>channel.subscription.gifts</b></div>
        <div id="subsBox" style="margin:10px 0;"></div>
        <div class="row">
          <button id="subscribeBtn" class="btn">‚ûï Zasubskrybuj teraz</button>
          <a class="btn" href="/setup" target="_blank">‚öôÔ∏è Przejd≈∫ do /setup</a>
        </div>
      </div>

      <!-- KO≈ÅO: konfiguracja + MOTYW + BONUS SPIN + poprawki wag -->
      <div class="card" style="grid-column: 1 / -1;">
        <h2>üéõÔ∏è Ko≈Ço ‚Äì konfiguracja & motyw</h2>
        <div class="muted">
          To te same dane co w overlayu. Zapis idzie na serwer (<code>/config</code>).
          Wagi przy zapisie sƒÖ automatycznie skalowane do 100% i zaokrƒÖglane do pe≈Çnych.
          Minimalna waga pozycji to 1%.
        </div>

        <!-- Admin key -->
        <div class="row" style="margin:8px 0;">
          <input type="text" id="adminKey" placeholder="X-Admin-Key" />
          <button class="btn" id="saveKeyBtn">üíæ Zapisz klucz</button>
          <button class="btn" id="loadCfgBtn">‚¨áÔ∏è Wczytaj</button>
        </div>

        <!-- Theme picker + previews -->
        <div class="row" style="margin:10px 0;">
          <label for="themeSel" class="muted">Motyw:&nbsp;</label>
          <select id="themeSel">
            <option value="wood">Wood (drewniany)</option>
            <option value="classic">Classic (metal/srebro)</option>
          </select>

          <div class="row" style="gap:16px; margin-left:auto;">
            <div>
              <div class="muted small">PodglƒÖd: wood</div>
              <div class="thumb"><canvas id="prevWood" class="preview" width="140" height="140"></canvas></div>
            </div>
            <div>
              <div class="muted small">PodglƒÖd: classic</div>
              <div class="thumb"><canvas id="prevClassic" class="preview" width="140" height="140"></canvas></div>
            </div>
          </div>
        </div>

        <!-- List editor -->
        <div id="wheelList" style="margin-top:10px;"></div>

        <div class="row" style="margin-top:8px;">
          <input type="text" id="newLabel" placeholder="Nowa nagroda‚Ä¶" />
          <input type="number" id="newWeight" placeholder="Waga (%)" min="1" step="1" />
          <label class="chk"><input type="checkbox" id="newBonus" /> Bonus: dodatkowy spin</label>
          <button class="btn" id="addItemBtn">Dodaj</button>
        </div>

        <div class="row" style="margin-top:12px;">
          <button class="btn" id="normalizeBtn">üìè Normalizuj do 100% (pe≈Çne %)</button>
          <button class="btn" id="saveCfgBtn">‚¨ÜÔ∏è Zapisz (items + theme)</button>
          <button class="btn" id="testSpinBtn">üéØ Wy≈õlij testowy spin</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // === Utils
    function el(id){ return document.getElementById(id); }
    function msgHTML(ok, text) { return ok ? `<span class="ok">${text}</span>` : `<span class="bad">${text}</span>`; }

    // === STATUS
    async function loadStatus(){
      const box = el("statusBox");
      box.textContent = "≈Åadowanie‚Ä¶";
      try {
        const r = await fetch("/status", { cache: "no-store" });
        const j = await r.json();
        if (!j?.ok) throw new Error(j?.error || "Brak ok");
        const lines = [];
        lines.push(`Token: ${j.hasTokens ? '<span class="ok">OK</span>' : '<span class="bad">brak</span>'}`);
        if (j.scope) lines.push(`<div>Scope: <code>${j.scope}</code></div>`);
        if (j.broadcaster_user_id) lines.push(`<div>Broadcaster ID: <code>${j.broadcaster_user_id}</code></div>`);
        box.innerHTML = lines.join("");
        await loadSubs(j);
      } catch (e) {
        box.innerHTML = msgHTML(false, "B≈ÇƒÖd statusu: " + e.message);
      }
    }

    async function loadSubs(statusJson){
      const subsBox = el("subsBox");
      const j = statusJson || (await (await fetch("/status", { cache:"no-store" })).json());
      if (!j.ok) { subsBox.innerHTML = msgHTML(false, "B≈ÇƒÖd statusu"); return; }
      const subs = Array.isArray(j.subscriptions) ? j.subscriptions : [];
      if (!subs.length) {
        subsBox.innerHTML = '<div class="muted">Brak subskrypcji. Kliknij ‚ÄûZasubskrybuj teraz‚Äù.</div>';
        return;
      }
      let html = `<table><thead><tr><th>Nazwa</th><th>Wersja</th><th>ID</th></tr></thead><tbody>`;
      for (const s of subs) {
        html += `<tr>
          <td>${s.name || "-"}</td>
          <td>${s.version ?? "-"}</td>
          <td class="mono small">${s.subscription_id || "-"}</td>
        </tr>`;
      }
      html += `</tbody></table>`;
      subsBox.innerHTML = html;
    }

    el("refreshBtn").onclick = loadStatus;
    el("subscribeBtn").onclick = async () => {
      try {
        const r = await fetch("/subscribe", { method: "POST", headers: { "Content-Type": "application/json" }, body: "{}" });
        const j = await r.json();
        if (!j.ok) throw new Error(j.error || "Nie uda≈Ço siƒô subskrybowaƒá");
        alert("Subskrypcja OK.");
        loadStatus();
      } catch (e) {
        alert("B≈ÇƒÖd subskrypcji: " + e.message);
      }
    };

    // === CONFIG (items + theme + bonus)
    const defaultItems = [
      { label:"VIP na 24h", weight:10, bonus:false },
      { label:"≈öpiewasz 30s", weight:10, bonus:false },
      { label:"Mem na IG", weight:10, bonus:false },
      { label:"Reroll", weight:10, bonus:true },
      { label:"Wyb√≥r czatu", weight:10, bonus:false },
      { label:"Shot (18+)", weight:10, bonus:false },
      { label:"Giveaway 1x", weight:10, bonus:false },
      { label:"Wyb√≥r mapy", weight:10, bonus:false },
    ];
    let items = [];
    let theme = "wood";

    function sanitizeItem(it){
      const label = String(it?.label ?? "").trim();
      // minimalnie 1%
      const weight = Math.max(1, Math.round(Number(it?.weight) || 0));
      const bonus  = Boolean(it?.bonus);
      return { label, weight, bonus };
    }

    async function loadWheel(){
      try {
        const r = await fetch("/config", { cache: "no-store" });
        const j = await r.json();
        items = Array.isArray(j?.items) && j.items.length ? j.items.map(sanitizeItem) : defaultItems.slice().map(sanitizeItem);
        theme = typeof j?.theme === "string" ? j.theme : "wood";
      } catch {
        items = defaultItems.slice().map(sanitizeItem);
        theme = "wood";
      }
      el("themeSel").value = theme;
      renderWheelList();
      renderPreviews();
    }

    function renderWheelList(){
      const box = el("wheelList");
      let html = `<table>
        <thead>
          <tr>
            <th style="width:46%;">Nagroda</th>
            <th style="width:16%;">Waga (%)</th>
            <th style="width:20%;">Bonus spin</th>
            <th style="width:18%;"></th>
          </tr>
        </thead>
        <tbody>`;
      items.forEach((it, idx) => {
        const safeLabel = (it.label??"").replaceAll('"','&quot;');
        html += `<tr>
          <td><input data-i="${idx}" data-k="label" type="text" value="${safeLabel}"></td>
          <td><input data-i="${idx}" data-k="weight" type="number" min="1" step="1" value="${Math.max(1, Math.round(Number(it.weight)||1))}"></td>
          <td>
            <label class="chk">
              <input type="checkbox" data-i="${idx}" data-k="bonus" ${it.bonus ? "checked":""} />
              <span class="small muted">dodatkowe zakrƒôcenie</span>
            </label>
          </td>
          <td>
            <button class="btn small" data-up="${idx}">‚Üë</button>
            <button class="btn small" data-down="${idx}">‚Üì</button>
            <button class="btn small" data-del="${idx}">Usu≈Ñ</button>
          </td>
        </tr>`;
      });
      html += `</tbody></table>`;
      box.innerHTML = html;

      // inputs
      box.querySelectorAll("input[data-i]").forEach(inp => {
        inp.addEventListener("change", () => {
          const i = Number(inp.dataset.i);
          const k = String(inp.dataset.k);
          if (k === "weight") {
            let v = Math.round(Number(inp.value)||1);
            if (v < 1) v = 1;
            items[i][k] = v;
            inp.value = v; // natychmiastowe poprawienie UI
          } else if (k === "label") {
            items[i][k] = String(inp.value||"").trim();
          } else if (k === "bonus") {
            items[i][k] = inp.checked;
          }
          renderPreviewsDebounced();
        });
      });
      // delete
      box.querySelectorAll("button[data-del]").forEach(btn => {
        btn.onclick = () => {
          const i = Number(btn.dataset.del);
          items.splice(i,1);
          renderWheelList();
          renderPreviewsDebounced();
        };
      });
      // reorders
      box.querySelectorAll("button[data-up]").forEach(btn => {
        btn.onclick = () => {
          const i = Number(btn.dataset.up);
          if (i>0){ [items[i-1], items[i]] = [items[i], items[i-1]]; renderWheelList(); renderPreviewsDebounced(); }
        };
      });
      box.querySelectorAll("button[data-down]").forEach(btn => {
        btn.onclick = () => {
          const i = Number(btn.dataset.down);
          if (i < items.length-1){ [items[i+1], items[i]] = [items[i], items[i+1]]; renderWheelList(); renderPreviewsDebounced(); }
        };
      });
    }

    // --- NORMALIZACJA: pe≈Çne % i suma = 100 (metoda najwiƒôkszych reszt) ---
    function normalizeWeightsTo100(list) {
      const n = list.length;
      if (!n) return [];

      // Je≈õli wszystkie 0 (nie powinno siƒô zdarzyƒá, ale asekuracyjnie):
      const sumRaw = list.reduce((s, it) => s + Math.max(0, Number(it.weight)||0), 0);
      if (sumRaw <= 0) {
        // r√≥wny podzia≈Ç pe≈Çnymi procentami
        const base = Math.floor(100 / n);
        let rest = 100 - base * n;
        return list.map((it, i) => ({
          ...it,
          weight: base + (i < rest ? 1 : 0)
        }));
      }

      // Skala do 100
      const scaled = list.map((it) => {
        const raw = Math.max(0, Number(it.weight)||0);
        const val = (raw / sumRaw) * 100;
        return { ...it, _val: val };
      });

      // Czƒô≈õƒá ca≈Çkowita + reszty
      const floored = scaled.map((it) => ({ ...it, weight: Math.floor(it._val), _frac: it._val - Math.floor(it._val) }));
      let total = floored.reduce((s, it) => s + it.weight, 0);
      let remain = 100 - total;

      // Rozdaj po 1% tym z najwiƒôkszƒÖ resztƒÖ
      floored.sort((a, b) => b._frac - a._frac);
      for (let i = 0; i < floored.length && remain > 0; i++, remain--) {
        floored[i].weight += 1;
      }

      // Minimalnie 1% dla ka≈ºdej pozycji
      let debt = 0;
      for (const it of floored) {
        if (it.weight < 1) { debt += (1 - it.weight); it.weight = 1; }
      }
      // Je≈õli co≈õ po korekcie przekroczy≈Ço 100, odbierz 1% od najmniejszych u≈Çamk√≥w
      if (debt > 0) {
        floored.sort((a, b) => (a._frac - b._frac) || (a.weight - b.weight)); // najpierw najmniejsza reszta i waga
        for (let i = 0; i < floored.length && debt > 0; i++) {
          if (floored[i].weight > 1) { floored[i].weight -= 1; debt--; i = -1; } // restart pƒôtli po zmianie
        }
      }

      // Odrzuƒá pola pomocnicze i posortuj z powrotem wg oryginalnej kolejno≈õci (nie zmieniali≈õmy, wiƒôc tylko strip):
      return floored.map(({ _val, _frac, ...rest }) => rest);
    }

    // Admin key local
    el("saveKeyBtn").onclick = () => {
      localStorage.setItem("ADMIN_KEY", (el("adminKey").value||"").trim());
      alert("Zapisano X-Admin-Key lokalnie.");
    };
    el("loadCfgBtn").onclick = loadWheel;

    // Add item
    el("addItemBtn").onclick = () => {
      const label = (el("newLabel").value||"").trim();
      let w = Math.round(Number(el("newWeight").value)||1);
      if (w < 1) w = 1;
      const b = el("newBonus").checked;
      if (!label) return;
      items.push({ label, weight: w, bonus: b });
      el("newLabel").value = ""; el("newWeight").value = ""; el("newBonus").checked = false;
      renderWheelList();
      renderPreviewsDebounced();
    };

    // Theme change
    el("themeSel").onchange = () => {
      theme = el("themeSel").value || "wood";
      renderPreviews();
    };

    // Save config
    el("saveCfgBtn").onclick = async () => {
      try {
        // 1) dopilnuj min 1%
        items = items.map(sanitizeItem);
        // 2) normalizacja do pe≈Çnych %
        items = normalizeWeightsTo100(items);
        renderWheelList();

        const key = localStorage.getItem("ADMIN_KEY") || el("adminKey").value || "";
        const r = await fetch("/config", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-Admin-Key": key },
          body: JSON.stringify({ items, theme })
        });
        if (!r.ok) throw new Error(await r.text());
        alert("Zapisano na serwerze (pe≈Çne % z sumƒÖ 100, motyw i bonusy zapisane).");
      } catch (e) {
        alert("B≈ÇƒÖd zapisu: " + e.message);
      }
    };

    // Normalize only
    el("normalizeBtn").onclick = () => {
      items = items.map(sanitizeItem);
      items = normalizeWeightsTo100(items);
      renderWheelList();
      renderPreviewsDebounced();
    };

    // Test spin
    el("testSpinBtn").onclick = async () => {
      try {
        await fetch("/test/1", { cache: "no-store" });
        alert("Wys≈Çano testowy spin.");
      } catch {
        alert("Nie uda≈Ço siƒô wywo≈Çaƒá testowego spinu.");
      }
    };

    // ==== Mini PREVIEWS (wood/classic) ‚Äì uproszczone rysowanie ====
    const prevWood = el("prevWood");
    const prevClassic = el("prevClassic");
    const ctxW = prevWood.getContext("2d");
    const ctxC = prevClassic.getContext("2d");

    function drawPreview(ctx, mode, list){
      const W=140, H=140, CX=W/2, CY=H/2, R=52;
      ctx.clearRect(0,0,W,H);

      if (mode === "wood"){
        ctx.beginPath(); ctx.arc(CX,CY,R+10,0,2*Math.PI);
        ctx.fillStyle="#b8860b"; ctx.fill();
        ctx.lineWidth=4; ctx.strokeStyle="#6b4513"; ctx.stroke();
      } else {
        const g = ctx.createRadialGradient(CX, CY, R*0.6, CX, CY, R+12);
        g.addColorStop(0, "#d9dee5"); g.addColorStop(0.5, "#8f99a8"); g.addColorStop(1, "#e9eef5");
        ctx.beginPath(); ctx.arc(CX,CY,R+12,0,2*Math.PI); ctx.fillStyle=g; ctx.fill();
      }

      const sum = list.reduce((s,it)=>s+Math.max(0,Number(it.weight)||0),0) || 1;
      let a = -Math.PI/2;
      const colorsWood = ["#FF4D4F","#40A9FF","#73D13D","#FAAD14","#9254DE","#13C2C2","#EB2F96","#A0D911"];
      const colorsCl   = ["#FF3B3B","#1E90FF","#2ED573","#FFC107","#A55EEA","#17A2B8","#FF6B6B","#7bed9f"];
      for (let i=0;i<list.length;i++){
        const frac = Math.max(0, Number(list[i].weight)||0)/sum;
        const b = a + frac*2*Math.PI;
        ctx.beginPath();
        ctx.moveTo(CX,CY);
        ctx.arc(CX,CY,R,a,b);
        ctx.closePath();
        ctx.fillStyle = (mode==="wood" ? colorsWood : colorsCl)[i % 8];
        ctx.fill();
        ctx.lineWidth = 1; ctx.strokeStyle = "rgba(255,255,255,.6)"; ctx.stroke();
        a = b;
      }

      // hub
      if (mode === "wood"){
        ctx.beginPath(); ctx.arc(CX,CY,R*0.45,0,2*Math.PI);
        const hg=ctx.createRadialGradient(CX,CY,2,CX,CY,R*0.45);
        hg.addColorStop(0,"#f1c27d"); hg.addColorStop(1,"#8b5a2b");
        ctx.fillStyle=hg; ctx.fill();
        ctx.lineWidth=2; ctx.strokeStyle="#5e3d1e"; ctx.stroke();
      } else {
        ctx.beginPath(); ctx.arc(CX,CY,R*0.45,0,2*Math.PI);
        const gg=ctx.createRadialGradient(CX-4,CY-4,2,CX,CY,R*0.45);
        gg.addColorStop(0,"#ffffff"); gg.addColorStop(1,"#90a4c4");
        ctx.fillStyle=gg; ctx.fill();
        ctx.lineWidth=2; ctx.strokeStyle="#9aa3b2"; ctx.stroke();
      }
    }

    let previewTimer;
    function renderPreviews(){
      const list = items.length ? items : defaultItems;
      drawPreview(ctxW, "wood", list);
      drawPreview(ctxC, "classic", list);
    }
    function renderPreviewsDebounced(){
      clearTimeout(previewTimer);
      previewTimer = setTimeout(renderPreviews, 60);
    }

    // BOOT
    (async function(){
      el("adminKey").value = localStorage.getItem("ADMIN_KEY") || "";
      await loadStatus();
      await loadWheel();
    })();
  </script>
</body>
</html>
