<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Delay Timer</title>
  <style>
    html, body { margin:0; padding:0; background:transparent; overflow:hidden; }
    .delay-overlay { position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); 
      opacity: 0; transition: opacity .4s ease; pointer-events: none; z-index: 15;
      padding: 20px 32px; border-radius: 16px; background: rgba(17, 17, 17, 0.92); 
      color: #fff; font-family: system-ui, sans-serif; text-align: center;
      box-shadow: 0 10px 40px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.1);
      backdrop-filter: blur(8px); }
    .delay-overlay.show { opacity: 1; }
    .delay-overlay h3 { margin: 0 0 12px 0; font-size: 24px; font-weight: 700; color: #fbbf24; }
    .delay-overlay .time { font-size: 48px; font-weight: 800; margin: 8px 0; color: #fff; 
      font-variant-numeric: tabular-nums; letter-spacing: 2px; }
    .delay-overlay .pending { font-size: 14px; color: #9ca3af; margin-top: 8px; }
    .delay-overlay .pending strong { color: #fbbf24; }
  </style>
</head>
<body>
  <div id="delayOverlay" class="delay-overlay" aria-hidden="true">
    <h3>‚è±Ô∏è Nastepne ko≈Ço za:</h3>
    <div class="time" id="delayTime">0:00</div>
    <div class="pending" id="delayPending"></div>
  </div>

  <script>
    // ====== Delay overlay ======
    const delayOverlay = document.getElementById("delayOverlay");
    const delayTimeEl = document.getElementById("delayTime");
    const delayPendingEl = document.getElementById("delayPending");
    let currentDelaySeconds = 0;
    let pendingCount = 0;
    let delayUpdateInterval = null;

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${String(secs).padStart(2, '0')}`;
    }

    function updateDelayDisplay() {
      if (currentDelaySeconds > 0) {
        delayTimeEl.textContent = formatTime(currentDelaySeconds);
        if (pendingCount > 0) {
          delayPendingEl.innerHTML = `<strong>${pendingCount}</strong> spinow${pendingCount !== 1 ? 's' : ''} w kolejce`;
        } else {
          delayPendingEl.textContent = "";
        }
        delayOverlay.classList.add("show");
        delayOverlay.setAttribute("aria-hidden", "false");
      } else {
        delayOverlay.classList.remove("show");
        delayOverlay.setAttribute("aria-hidden", "true");
        if (delayUpdateInterval) {
          clearInterval(delayUpdateInterval);
          delayUpdateInterval = null;
        }
      }
    }

    function startDelayCountdown(seconds, pending = 0) {
      currentDelaySeconds = seconds;
      pendingCount = pending;
      updateDelayDisplay();
      
      if (delayUpdateInterval) clearInterval(delayUpdateInterval);
      delayUpdateInterval = setInterval(() => {
        if (currentDelaySeconds > 0) {
          currentDelaySeconds--;
          updateDelayDisplay();
        } else {
          clearInterval(delayUpdateInterval);
          delayUpdateInterval = null;
        }
      }, 1000);
    }

    // ====== WebSocket connection ======
    const WS_URL = (location.protocol === 'https:' ? 'wss' : 'ws') + '://' + location.host + '/ws';
    let ws = null;
    let reconnectDelay = 1000;
    let lastWsMessageTime = Date.now();

    function handleServerMessage(data) {
      lastWsMessageTime = Date.now();
      if (data.type === "delay" && Number.isFinite(data.timeUntilNext)) {
        startDelayCountdown(data.timeUntilNext, data.pending || 0);
        return;
      }
    }

    async function fetchDelayStatus() {
      try {
        const r = await fetch('/spins/pending', { cache: 'no-store' });
        const j = await r.json();
        const timeUntilNext = Math.max(0, Number(j?.timeUntilNext || 0));
        const pending = Math.max(0, Number(j?.count || 0));
        if (timeUntilNext > 0 || pending > 0) {
          startDelayCountdown(timeUntilNext, pending);
        } else {
          // No delay active, hide overlay
          currentDelaySeconds = 0;
          updateDelayDisplay();
        }
      } catch (e) {
        console.error("[DELAY] Failed to fetch status:", e);
      }
    }

    // Simple wake-up check for delay overlay
    async function checkDelayStatus() {
      try {
        const r = await fetch('/spins/pending', { cache: 'no-store' });
        const j = await r.json();
        const timeUntilNext = Math.max(0, Number(j?.timeUntilNext || 0));
        const pending = Math.max(0, Number(j?.count || 0));
        
        if (timeUntilNext > 0 || pending > 0) {
          startDelayCountdown(timeUntilNext, pending);
        } else {
          currentDelaySeconds = 0;
          updateDelayDisplay();
        }
      } catch (e) {
        console.error("[DELAY] Failed to check:", e);
      }
    }

    function connectWS() {
      try { if (ws) ws.close(); } catch {}
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        console.log("[DELAY WS] ‚úÖ Connected (nice-to-have for instant updates)");
        reconnectDelay = 1000;
      };
      
      ws.onmessage = (evt) => {
        console.log("[DELAY WS] üì• Got update:", evt.data);
        try { handleServerMessage(JSON.parse(evt.data)); } 
        catch (e) { console.error("[DELAY WS] Bad message", e); }
      };
      
      ws.onerror = () => { 
        console.log("[DELAY WS] ‚ö†Ô∏è Error (no problem, we have wake-up check)");
        try { ws.close(); } catch {} 
      };
      
      ws.onclose = () => {
        console.log("[DELAY WS] ‚ùå Disconnected (no problem)");
        setTimeout(connectWS, 10000); // Try again in 10 seconds
      };
    }

    // Connect once
    connectWS();
    
    // Check every 5 seconds while visible (simple periodic update for countdown)
    setInterval(checkDelayStatus, 5000);

    // === SIMPLE WAKE-UP SYSTEM ===
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) {
        console.log("[DELAY OBS] üëÅÔ∏è Overlay visible - checking for updates");
        checkDelayStatus(); // Simple: ask server once
      }
    });

    // OBS-specific event
    window.addEventListener("obsSourceActiveChanged", (event) => {
      if (event.detail?.active) {
        console.log("[DELAY OBS] üé¨ Source activated - checking for updates");
        checkDelayStatus(); // Simple: ask server once
      }
    });
  </script>
</body>
</html>
